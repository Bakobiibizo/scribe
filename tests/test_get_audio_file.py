# Generated by CodiumAI
import os
import time

import pytest

from ..src.scriber import get_audio_file


class TestGetAudioFile:
    # Tests that function returns a valid audio file when directory 'in' exists and contains at least one audio file
    # with a valid extension.
    def test_existing_directory(self):
        file_name = get_audio_file()
        assert file_name is not None
        assert os.path.isfile(file_name)
        assert file_name.endswith((".mp3", ".mp4", ".mkv", ".wav"))

    #  Tests that function returns None when directory 'in' does not exist.
    def test_non_existing_directory(self):
        with pytest.raises(TypeError):
            get_audio_file()

    #  Tests that function returns None when directory 'in' exists but is empty.
    def test_empty_directory(self):
        os.makedirs("in")
        assert get_audio_file() is None
        os.rmdir("in")

    # Tests that function returns None when directory 'in' exists but does not contain any audio files with a valid
    # extension.
    def test_no_audio_files(self):
        with open("in/test.txt", "w") as f:
            f.write("test")
        assert get_audio_file() is None
        os.remove("in/test.txt")

    # Tests that function returns the first audio file found when multiple audio files with valid extensions exist
    # in 'in' directory.
    def test_multiple_audio_files(self):
        with open("in/test1.mp3", "w") as f:
            f.write("test")
        with open("in/test2.wav", "w") as f:
            f.write("test")
        assert get_audio_file() == "in/test1.mp3"
        os.remove("in/test1.mp3")
        os.remove("in/test2.wav")

    # Tests that function returns the audio file with the most recent modified date when multiple audio files with
    # valid extensions exist in 'in' directory.
    def test_multiple_audio_files_modified_date(self):
        with open("in/test1.mp3", "w") as f:
            f.write("test")
        with open("in/test2.wav", "w") as f:
            f.write("test")
        os.utime("in/test1.mp3", (0, 1000000000))
        assert get_audio_file() == "in/test2.wav"
        os.remove("in/test1.mp3")
        os.remove("in/test2.wav")

    #  Tests that the function returns the file with the earliest modified date.
    def test_earliest_modified_date(self):
        expected_file = os.path.abspath("in/test1.mp3")
        with open(expected_file, "w") as f:
            f.write("test")
        time.sleep(1)
        os.utime(os.path.abspath("in/test2.mp3"), None)
        actual_file = get_audio_file()
        os.remove(expected_file)
        assert actual_file == os.path.abspath("in/test1.mp3"), (
            "Function did not return file with earliest modified " "date."
        )

    # Tests that get_audio_file returns the file with the largest size when multiple audio files with valid
    # extensions exist in the 'in' directory.
    def test_get_audio_file_returns_file_with_largest_size(self):
        expected_file = None
        expected_size = 0
        for file in os.listdir("in"):
            if file.endswith((".mp3", ".mp4", ".mkv", ".wav")):
                file_path = os.path.join("in", file)
                size = os.path.getsize(file_path)
                if size > expected_size:
                    expected_file = file_path
                    expected_size = size
        assert (
            get_audio_file() == expected_file
        ), "get_audio_file did not return the file with the largest size."

        # ensure this returns a valid .mp3, .mp4, .mkv, or .wav relative file path for its location

    #  Tests that the function returns the file with the smallest file size.
    def test_smallest_file_size(self):
        expected_output = os.path.abspath("in/test.wav")
        assert get_audio_file() == expected_output, (
            "ensure this returns a valid .mp3, .mp4, .mkv, or .wav relative "
            "file path for its location"
        )
